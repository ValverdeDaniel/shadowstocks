day7_watchlistArc


=========================================
âœ… WATCHLIST EXPANSION PLAN & CODE
=========================================

1) EXTEND MODELS
---------------
In contracts/models.py:

class SavedContract(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    label = models.CharField(max_length=100, blank=True, default='')
    ticker = models.CharField(max_length=10)
    option_type = models.CharField(max_length=4)
    strike = models.FloatField()
    expiration = models.DateField()
    days_to_gain = models.IntegerField()
    number_of_contracts = models.IntegerField()
    average_cost_per_contract = models.FloatField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.label or self.ticker} ({self.option_type.upper()})"

class WatchlistGroup(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    contracts = models.ManyToManyField(SavedContract, related_name="groups")
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Group: {self.name}"

Run migrations:
$ python manage.py makemigrations contracts
$ python manage.py migrate


2) ADD SERIALIZERS
-------------------
In contracts/serializers.py:

from rest_framework import serializers
from .models import SavedContract, WatchlistGroup

class SavedContractSerializer(serializers.ModelSerializer):
    class Meta:
        model = SavedContract
        fields = '__all__'

class WatchlistGroupSerializer(serializers.ModelSerializer):
    contracts = SavedContractSerializer(many=True, read_only=True)
    class Meta:
        model = WatchlistGroup
        fields = '__all__'


3) ADD VIEWS
-------------
In contracts/views.py:

from rest_framework import generics, status
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.permissions import IsAuthenticated
from .models import SavedContract, WatchlistGroup
from .serializers import SavedContractSerializer, WatchlistGroupSerializer
from .utils import run_multiple_analyses

class SavedContractListCreateAPIView(generics.ListCreateAPIView):
    permission_classes = [IsAuthenticated]
    serializer_class = SavedContractSerializer

    def get_queryset(self):
        return SavedContract.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class SavedContractDeleteAPIView(generics.DestroyAPIView):
    permission_classes = [IsAuthenticated]
    queryset = SavedContract.objects.all()
    serializer_class = SavedContractSerializer

class WatchlistGroupListCreateAPIView(generics.ListCreateAPIView):
    permission_classes = [IsAuthenticated]
    serializer_class = WatchlistGroupSerializer

    def get_queryset(self):
        return WatchlistGroup.objects.filter(user=self.request.user)

    def perform_create(self, serializer):
        serializer.save(user=self.request.user)

class WatchlistGroupUpdateDeleteAPIView(generics.RetrieveUpdateDestroyAPIView):
    permission_classes = [IsAuthenticated]
    queryset = WatchlistGroup.objects.all()
    serializer_class = WatchlistGroupSerializer

class RunBulkWatchlistAPIView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        contract_ids = request.data.get('contract_ids', [])
        contracts = SavedContract.objects.filter(user=request.user, id__in=contract_ids)

        if not contracts:
            return Response({'error': 'No valid contracts found.'}, status=400)

        contracts_data = [
            {
                'ticker': c.ticker,
                'option_type': c.option_type,
                'strike': c.strike,
                'expiration': c.expiration.isoformat(),
                'days_to_gain': c.days_to_gain,
                'number_of_contracts': c.number_of_contracts,
                'average_cost_per_contract': c.average_cost_per_contract,
            }
            for c in contracts
        ]

        results = run_multiple_analyses(contracts_data)
        return Response(results, status=200)


4) UPDATE URLS
---------------
In contracts/urls.py:

urlpatterns += [
    path('saved-contracts/', views.SavedContractListCreateAPIView.as_view(), name='saved-contracts'),
    path('saved-contracts/<int:pk>/', views.SavedContractDeleteAPIView.as_view(), name='delete-contract'),
    path('watchlist-groups/', views.WatchlistGroupListCreateAPIView.as_view(), name='watchlist-groups'),
    path('watchlist-groups/<int:pk>/', views.WatchlistGroupUpdateDeleteAPIView.as_view(), name='update-delete-group'),
    path('run-bulk-watchlist/', views.RunBulkWatchlistAPIView.as_view(), name='run-bulk-watchlist'),
]


5) FRONTEND CHANGES
-------------------
In WatchlistParamsForm.js:
--------------------------
Add Save Contract handler:

const handleSave = async () => {
  try {
    const response = await fetch('/api/saved-contracts/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(params),
    });
    if (!response.ok) throw new Error('Failed to save contract');
    alert('Contract saved successfully!');
  } catch (error) {
    console.error('Error saving contract:', error);
  }
};

Add Save button to your JSX:

<button type="button" onClick={handleSave} className="btn-secondary">Save Contract</button>


In Watchlist.js:
-----------------
Add state:

const [savedContracts, setSavedContracts] = useState([]);
const [selectedContracts, setSelectedContracts] = useState([]);

Load saved contracts on mount:

useEffect(() => {
  const fetchSavedContracts = async () => {
    try {
      const response = await fetch('/api/saved-contracts/');
      const data = await response.json();
      setSavedContracts(data);
    } catch (error) {
      console.error('Error loading saved contracts:', error);
    }
  };
  fetchSavedContracts();
}, []);

Add handler to run selected contracts:

const handleRunSelected = async () => {
  try {
    const response = await fetch('/api/run-bulk-watchlist/', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ contract_ids: selectedContracts }),
    });
    if (!response.ok) throw new Error('Failed to run selected contracts');
    const data = await response.json();
    setWatchlistItems((prev) => [...prev, ...data]);
  } catch (error) {
    console.error('Error running selected contracts:', error);
  }
};


In WatchlistSavedParams.js:
---------------------------
Add checkbox for multi-select inside your saved contract map:

<input
  type="checkbox"
  checked={selectedContracts.includes(param.id)}
  onChange={(e) => {
    if (e.target.checked) {
      setSelectedContracts((prev) => [...prev, param.id]);
    } else {
      setSelectedContracts((prev) => prev.filter((id) => id !== param.id));
    }
  }}
/>

Add button to run selected contracts:

{selectedContracts.length > 0 && (
  <button onClick={handleRunSelected} className="btn-primary">
    Run Selected Contracts
  </button>
)}


6) FINAL NOTES
---------------
âœ… This setup lets you:
- Save individual contracts
- View saved contracts
- Select multiple saved contracts
- Run bulk simulations for selected contracts
- Display combined results in your WatchlistTable

ðŸš€ You're ready to build groups next!

