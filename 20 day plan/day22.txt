
📘 Day 22: API & Integration Testing for Django Endpoints (Longform Learning Guide)

==================================================================
📌 Objective
==================================================================
Today, you will:
- Write automated tests for your Django API endpoints
- Validate response formats, status codes, and business logic
- Cover integration points like strategy submission and ROI simulation
- Catch edge cases like invalid inputs and missing parameters

==================================================================
🧠 Why API Tests Matter
==================================================================
- Ensure your backend behaves as expected when triggered by React
- Prevent silent failures that can frustrate users
- Catch regressions when adding new features
- Speed up confidence in production deployment

==================================================================
🛠️ Step 1: Add Factory Boy for Test Fixtures
==================================================================

Install factory_boy and faker:

```bash
pip install factory_boy faker
```

In `factories.py`:

```python
import factory
from django.contrib.auth.models import User
from yourapp.models import UserProfile

class UserFactory(factory.django.DjangoModelFactory):
    class Meta:
        model = User

    username = factory.Sequence(lambda n: f"user{n}")
    email = factory.LazyAttribute(lambda o: f"{o.username}@test.com")

    @factory.post_generation
    def profile(self, create, extracted, **kwargs):
        if create:
            UserProfile.objects.get_or_create(user=self)
```

==================================================================
🧪 Step 2: Test Screener Endpoint
==================================================================

In `tests/test_views.py`:

```python
import pytest
from rest_framework.test import APIClient
from django.urls import reverse
from yourapp.factories import UserFactory

@pytest.mark.django_db
def test_screener_valid_query():
    client = APIClient()
    url = reverse("screener-endpoint")  # Change to match your endpoint

    response = client.post(url, {
        "tickers": ["AAPL", "MSFT"],
        "option_type": "call",
        "days_until_exp": 30,
        "strike_pct": 0.1,
        "days_to_gain": 20,
        "stock_gain_pct": 0.08,
        "allocation": 1000,
        "label": "Test Strategy"
    }, format="json")

    assert response.status_code == 200
    assert isinstance(response.data, list)
    assert "ticker" in response.data[0]

@pytest.mark.django_db
def test_screener_missing_params():
    client = APIClient()
    url = reverse("screener-endpoint")

    response = client.post(url, {"tickers": ["AAPL"]}, format="json")
    assert response.status_code == 400
```

==================================================================
📉 Step 3: Test ROI Simulation Endpoint
==================================================================

```python
@pytest.mark.django_db
def test_simulate_roi_endpoint():
    client = APIClient()
    url = reverse("simulate-roi")

    response = client.post(url, {
        "config": {
            "option_type": "call",
            "strike": 100,
            "average_cost_per_contract": 5.00
        },
        "price_series": [90, 95, 100, 110]
    }, format="json")

    assert response.status_code == 200
    assert len(response.data) == 4
    assert "roi" in response.data[-1]
```

==================================================================
🔐 Step 4: Test Authenticated Endpoints (e.g. Saved Setups)
==================================================================

```python
@pytest.mark.django_db
def test_saved_strategy_requires_login():
    client = APIClient()
    url = reverse("save-strategy")

    # Not authenticated
    response = client.post(url, {}, format="json")
    assert response.status_code == 403 or 401

    # With login
    user = UserFactory()
    client.force_authenticate(user=user)
    response = client.post(url, {
        "name": "Test Strategy",
        "config_data": {
            "option_type": "put",
            "strike": 200,
            "average_cost_per_contract": 3.5
        }
    }, format="json")

    assert response.status_code == 201
```

==================================================================
🧪 Step 5: Run Tests
==================================================================

```bash
pytest -v --cov=yourapp
```

You should now see success reports and coverage stats.

==================================================================
✅ What You’ve Accomplished
==================================================================

✔ Covered all major Django API endpoints  
✔ Wrote tests to handle both valid and broken input  
✔ Confirmed logic for screener, watchlist, ROI, and strategy saving  
✔ Used `factory_boy` to simplify user test creation  
✔ Now have API-level confidence before deploying

Next up: Day 23 – optional React component testing for forms and chart rendering!
